<!DOCTYPE html>
<html lang="en" dir="auto">

<head><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="index, follow">
<title>AVL树 | 回忆补时</title>
<meta name="keywords" content="" />
<meta name="description" content="题记：AVL树是笔者在上学时就一直没弄懂的数据结构，时隔多年重学数据结构，终于跨越了新手误区，成功理解了它的旋转，特作此文以记录一下。
 注：本文默认读者已对二叉查找树、AVL树的基本功能有了一个感性认识，因此不赘述其查询过程，也不分析其查询复杂度，仅就其理解上的难点给出说明。
 一、正确理解递归 树是一个典型的递归定义的数据结构，在树上执行的操作很多都是递归进行的，因此要理解树上的操作，我们首先需要正确理解递归。
笔者在第一次学习递归时，一度试图跟着递归调用一直走到递归终止，然后跟着递归弹栈，以理解全过程。这种策略在理解迭代型程序是可行的，但是理解递归程序切不可这么做。试图跟着递归程序理解其递归全过程，是新手学习递归过程中最容易进入的误区。
那么应该如何正确理解递归呢？我们可以考虑高中数学里一个常见的递归（递推）结构：数列。当我们描述一个数列时，有时我们可以给定一个数列的通项公式，但更多时候，通项公式并没有数列的递推公式容易得到。所以，也时常有数列是以递推公式&#43;首项的方式进行描述的，这其实就是理解递归的正确方式。
 在理解递归时，只需要考虑相邻结构，以及递归终止条件（即相当于数列首项）即可，数学结构保证了其有效性。
 二、二叉查找树  二叉查找树是指一棵空树或者具有下列性质的二叉树：
 若任意节点的左子树不空，则左子树上所有节点的值均小于它的根节点的值； 若任意节点的右子树不空，则右子树上所有节点的值均大于它的根节点的值； 任意节点的左、右子树也分别为二叉查找树；   上面是二叉查找树的正式的定义，其实一般情况下，只需要记住二叉查找树的左子树的值都小于根，右子树的值都大于根，就已足够。
二叉查找树的构建是通过一个值一个值插入来构建的，哪怕有一组用来构建二叉查找树的值，二叉查找树也只能通过逐个插入来构建。
举例：1、4、3、5、6、2、7 这个序列： 但同样的7个数字，如果不是按照上述插入方式插入的话，得到的二叉查找树的结构就会大相径庭。比如一个很容易发现的规律是：序列中第一个插入的元素一定会成为朴素二叉查找树的根节点。
三、AVL树 由于朴素二叉查找树在极端情况下（即插入序列为有序序列）构建的查找树退化成一个单链表，使得在二叉查找树上进行查询的时间复杂度退化成O(n)。因此，为了保证查询高效，我们必须在插入元素后，对树的结构进行调整，使树尽量「宽」，而非尽量「深」，使得树能够保证平均查询复杂度始终保持在O(logN)数量级。
为了衡量一棵树是否需要调整，我们需要有一个方式对树的状态进行度量。在AVL树中，我们选择的度量方式是比较子树的高度。
  路径长度：从根节点到叶子节点经过的节点数量（包含根节点和叶子结点） 树的高度：一棵树的所有路径里最长路径的长度   在AVL树结构中，当一棵树的左子树与右子树的高度差的绝对值超过2时，就需要对树的结构进行调整了，这种调整在一般的文章讨论中成为「旋转」，其实本质就是对树中一些指针的指向进行调整的过程，它和链表插入也没什么本质的区别，都是指针调整而已。
那么 AVL 树是怎么做的呢？
首先 AVL 树将需要调整的情况分成了四类：
 在左子树的左子树上做插入 在左子树的右子树上做插入 在右子树的左子树上做插入 在右子树的右子树上做插入  其中类型 1、4 镜像对称，类型 2、3 镜像对称。因此我们只需要研究类型 1 和类型 2 即可。
 这里额外插一句，从上文对情况分类讨论时的用词「左子树的左子树」「右子树的左子树」等，我们可以很清晰地发现关于 AVL 结构调整的操作是在两层（即子树，以及子树的子树）上去操作的，这一定程度上有别于一些简单的递归操作时仅仅只在一层上去操作，此处需要格外注意去理解。
  另外，关于如何找到要调整的根节点，这块看看具体的代码实现就清晰了，文字描述反而容易增加理解难度，因此此处不用文字赘述。
 1、4两种情况的处理 关于这种调整是如何进行的，也话不多说，看图即可。
上图描述了如何处理 在左子树的左子树上做插入， 即第一类情况需要做出的调整。 用文字描述的话就是：让根节点成为其左子树的右子树，然后让左子树原来的右子树成为根节点新的左子树。经过调整后，原左子树变成了根节点。">
<meta name="author" content="">
<link rel="canonical" href="/posts/avl-tree/" />
<link crossorigin="anonymous" href="/assets/css/stylesheet.min.502c80ee6d7b983cf2ffcc726988eab173abcad439327f3f7e8fc9c75b88c4c5.css" integrity="sha256-UCyA7m17mDzy/8xyaYjqsXOrytQ5Mn8/fo/Jx1uIxMU=" rel="preload stylesheet" as="style">
<script defer crossorigin="anonymous" src="/assets/js/highlight.min.4dcb3c4f38462f66c6b6137227726f5543cb934cca9788f041c087e374491df2.js" integrity="sha256-Tcs8TzhGL2bGthNyJ3JvVUPLk0zKl4jwQcCH43RJHfI="
    onload="hljs.initHighlightingOnLoad();"></script>
<link rel="icon" href="/favicon.ico">
<link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
<link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
<link rel="apple-touch-icon" href="/apple-touch-icon.png">
<link rel="mask-icon" href="/safari-pinned-tab.svg">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<meta name="generator" content="Hugo 0.94.2" />
<noscript>
    <style>
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
    <style>
        @media (prefers-color-scheme: dark) {
            :root {
                --theme: rgb(29, 30, 32);
                --entry: rgb(46, 46, 51);
                --primary: rgb(218, 218, 219);
                --secondary: rgb(155, 156, 157);
                --tertiary: rgb(65, 66, 68);
                --content: rgb(196, 196, 197);
                --hljs-bg: rgb(46, 46, 51);
                --code-bg: rgb(55, 56, 62);
                --border: rgb(51, 51, 51);
            }

            .list {
                background: var(--theme);
            }

            .list:not(.dark)::-webkit-scrollbar-track {
                background: 0 0;
            }

            .list:not(.dark)::-webkit-scrollbar-thumb {
                border-color: var(--theme);
            }
        }

    </style>
</noscript><meta property="og:title" content="AVL树" />
<meta property="og:description" content="题记：AVL树是笔者在上学时就一直没弄懂的数据结构，时隔多年重学数据结构，终于跨越了新手误区，成功理解了它的旋转，特作此文以记录一下。
 注：本文默认读者已对二叉查找树、AVL树的基本功能有了一个感性认识，因此不赘述其查询过程，也不分析其查询复杂度，仅就其理解上的难点给出说明。
 一、正确理解递归 树是一个典型的递归定义的数据结构，在树上执行的操作很多都是递归进行的，因此要理解树上的操作，我们首先需要正确理解递归。
笔者在第一次学习递归时，一度试图跟着递归调用一直走到递归终止，然后跟着递归弹栈，以理解全过程。这种策略在理解迭代型程序是可行的，但是理解递归程序切不可这么做。试图跟着递归程序理解其递归全过程，是新手学习递归过程中最容易进入的误区。
那么应该如何正确理解递归呢？我们可以考虑高中数学里一个常见的递归（递推）结构：数列。当我们描述一个数列时，有时我们可以给定一个数列的通项公式，但更多时候，通项公式并没有数列的递推公式容易得到。所以，也时常有数列是以递推公式&#43;首项的方式进行描述的，这其实就是理解递归的正确方式。
 在理解递归时，只需要考虑相邻结构，以及递归终止条件（即相当于数列首项）即可，数学结构保证了其有效性。
 二、二叉查找树  二叉查找树是指一棵空树或者具有下列性质的二叉树：
 若任意节点的左子树不空，则左子树上所有节点的值均小于它的根节点的值； 若任意节点的右子树不空，则右子树上所有节点的值均大于它的根节点的值； 任意节点的左、右子树也分别为二叉查找树；   上面是二叉查找树的正式的定义，其实一般情况下，只需要记住二叉查找树的左子树的值都小于根，右子树的值都大于根，就已足够。
二叉查找树的构建是通过一个值一个值插入来构建的，哪怕有一组用来构建二叉查找树的值，二叉查找树也只能通过逐个插入来构建。
举例：1、4、3、5、6、2、7 这个序列： 但同样的7个数字，如果不是按照上述插入方式插入的话，得到的二叉查找树的结构就会大相径庭。比如一个很容易发现的规律是：序列中第一个插入的元素一定会成为朴素二叉查找树的根节点。
三、AVL树 由于朴素二叉查找树在极端情况下（即插入序列为有序序列）构建的查找树退化成一个单链表，使得在二叉查找树上进行查询的时间复杂度退化成O(n)。因此，为了保证查询高效，我们必须在插入元素后，对树的结构进行调整，使树尽量「宽」，而非尽量「深」，使得树能够保证平均查询复杂度始终保持在O(logN)数量级。
为了衡量一棵树是否需要调整，我们需要有一个方式对树的状态进行度量。在AVL树中，我们选择的度量方式是比较子树的高度。
  路径长度：从根节点到叶子节点经过的节点数量（包含根节点和叶子结点） 树的高度：一棵树的所有路径里最长路径的长度   在AVL树结构中，当一棵树的左子树与右子树的高度差的绝对值超过2时，就需要对树的结构进行调整了，这种调整在一般的文章讨论中成为「旋转」，其实本质就是对树中一些指针的指向进行调整的过程，它和链表插入也没什么本质的区别，都是指针调整而已。
那么 AVL 树是怎么做的呢？
首先 AVL 树将需要调整的情况分成了四类：
 在左子树的左子树上做插入 在左子树的右子树上做插入 在右子树的左子树上做插入 在右子树的右子树上做插入  其中类型 1、4 镜像对称，类型 2、3 镜像对称。因此我们只需要研究类型 1 和类型 2 即可。
 这里额外插一句，从上文对情况分类讨论时的用词「左子树的左子树」「右子树的左子树」等，我们可以很清晰地发现关于 AVL 结构调整的操作是在两层（即子树，以及子树的子树）上去操作的，这一定程度上有别于一些简单的递归操作时仅仅只在一层上去操作，此处需要格外注意去理解。
  另外，关于如何找到要调整的根节点，这块看看具体的代码实现就清晰了，文字描述反而容易增加理解难度，因此此处不用文字赘述。
 1、4两种情况的处理 关于这种调整是如何进行的，也话不多说，看图即可。
上图描述了如何处理 在左子树的左子树上做插入， 即第一类情况需要做出的调整。 用文字描述的话就是：让根节点成为其左子树的右子树，然后让左子树原来的右子树成为根节点新的左子树。经过调整后，原左子树变成了根节点。" />
<meta property="og:type" content="article" />
<meta property="og:url" content="/posts/avl-tree/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2022-02-20T21:01:08&#43;08:00" />
<meta property="article:modified_time" content="2022-02-20T21:01:08&#43;08:00" />

<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="AVL树"/>
<meta name="twitter:description" content="题记：AVL树是笔者在上学时就一直没弄懂的数据结构，时隔多年重学数据结构，终于跨越了新手误区，成功理解了它的旋转，特作此文以记录一下。
 注：本文默认读者已对二叉查找树、AVL树的基本功能有了一个感性认识，因此不赘述其查询过程，也不分析其查询复杂度，仅就其理解上的难点给出说明。
 一、正确理解递归 树是一个典型的递归定义的数据结构，在树上执行的操作很多都是递归进行的，因此要理解树上的操作，我们首先需要正确理解递归。
笔者在第一次学习递归时，一度试图跟着递归调用一直走到递归终止，然后跟着递归弹栈，以理解全过程。这种策略在理解迭代型程序是可行的，但是理解递归程序切不可这么做。试图跟着递归程序理解其递归全过程，是新手学习递归过程中最容易进入的误区。
那么应该如何正确理解递归呢？我们可以考虑高中数学里一个常见的递归（递推）结构：数列。当我们描述一个数列时，有时我们可以给定一个数列的通项公式，但更多时候，通项公式并没有数列的递推公式容易得到。所以，也时常有数列是以递推公式&#43;首项的方式进行描述的，这其实就是理解递归的正确方式。
 在理解递归时，只需要考虑相邻结构，以及递归终止条件（即相当于数列首项）即可，数学结构保证了其有效性。
 二、二叉查找树  二叉查找树是指一棵空树或者具有下列性质的二叉树：
 若任意节点的左子树不空，则左子树上所有节点的值均小于它的根节点的值； 若任意节点的右子树不空，则右子树上所有节点的值均大于它的根节点的值； 任意节点的左、右子树也分别为二叉查找树；   上面是二叉查找树的正式的定义，其实一般情况下，只需要记住二叉查找树的左子树的值都小于根，右子树的值都大于根，就已足够。
二叉查找树的构建是通过一个值一个值插入来构建的，哪怕有一组用来构建二叉查找树的值，二叉查找树也只能通过逐个插入来构建。
举例：1、4、3、5、6、2、7 这个序列： 但同样的7个数字，如果不是按照上述插入方式插入的话，得到的二叉查找树的结构就会大相径庭。比如一个很容易发现的规律是：序列中第一个插入的元素一定会成为朴素二叉查找树的根节点。
三、AVL树 由于朴素二叉查找树在极端情况下（即插入序列为有序序列）构建的查找树退化成一个单链表，使得在二叉查找树上进行查询的时间复杂度退化成O(n)。因此，为了保证查询高效，我们必须在插入元素后，对树的结构进行调整，使树尽量「宽」，而非尽量「深」，使得树能够保证平均查询复杂度始终保持在O(logN)数量级。
为了衡量一棵树是否需要调整，我们需要有一个方式对树的状态进行度量。在AVL树中，我们选择的度量方式是比较子树的高度。
  路径长度：从根节点到叶子节点经过的节点数量（包含根节点和叶子结点） 树的高度：一棵树的所有路径里最长路径的长度   在AVL树结构中，当一棵树的左子树与右子树的高度差的绝对值超过2时，就需要对树的结构进行调整了，这种调整在一般的文章讨论中成为「旋转」，其实本质就是对树中一些指针的指向进行调整的过程，它和链表插入也没什么本质的区别，都是指针调整而已。
那么 AVL 树是怎么做的呢？
首先 AVL 树将需要调整的情况分成了四类：
 在左子树的左子树上做插入 在左子树的右子树上做插入 在右子树的左子树上做插入 在右子树的右子树上做插入  其中类型 1、4 镜像对称，类型 2、3 镜像对称。因此我们只需要研究类型 1 和类型 2 即可。
 这里额外插一句，从上文对情况分类讨论时的用词「左子树的左子树」「右子树的左子树」等，我们可以很清晰地发现关于 AVL 结构调整的操作是在两层（即子树，以及子树的子树）上去操作的，这一定程度上有别于一些简单的递归操作时仅仅只在一层上去操作，此处需要格外注意去理解。
  另外，关于如何找到要调整的根节点，这块看看具体的代码实现就清晰了，文字描述反而容易增加理解难度，因此此处不用文字赘述。
 1、4两种情况的处理 关于这种调整是如何进行的，也话不多说，看图即可。
上图描述了如何处理 在左子树的左子树上做插入， 即第一类情况需要做出的调整。 用文字描述的话就是：让根节点成为其左子树的右子树，然后让左子树原来的右子树成为根节点新的左子树。经过调整后，原左子树变成了根节点。"/>


<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BreadcrumbList",
  "itemListElement": [
    {
      "@type": "ListItem",
      "position":  1 ,
      "name": "Posts",
      "item": "/posts/"
    }
    {
      "@type": "ListItem",
      "position":  1 ,
      "name": "AVL树",
      "item": "/posts/avl-tree/"
    }
  ]
}
</script>
<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "AVL树",
  "name": "AVL树",
  "description": "题记：AVL树是笔者在上学时就一直没弄懂的数据结构，时隔多年重学数据结构，终于跨越了新手误区，成功理解了它的旋转，特作此文以记录一下。\n 注：本文默认读者已对二叉查找树、AVL树的基本功能有了一个感性认识，因此不赘述其查询过程，也不分析其查询复杂度，仅就其理解上的难点给出说明。\n 一、正确理解递归 树是一个典型的递归定义的数据结构，在树上执行的操作很多都是递归进行的，因此要理解树上的操作，我们首先需要正确理解递归。\n笔者在第一次学习递归时，一度试图跟着递归调用一直走到递归终止，然后跟着递归弹栈，以理解全过程。这种策略在理解迭代型程序是可行的，但是理解递归程序切不可这么做。试图跟着递归程序理解其递归全过程，是新手学习递归过程中最容易进入的误区。\n那么应该如何正确理解递归呢？我们可以考虑高中数学里一个常见的递归（递推）结构：数列。当我们描述一个数列时，有时我们可以给定一个数列的通项公式，但更多时候，通项公式并没有数列的递推公式容易得到。所以，也时常有数列是以递推公式+首项的方式进行描述的，这其实就是理解递归的正确方式。\n 在理解递归时，只需要考虑相邻结构，以及递归终止条件（即相当于数列首项）即可，数学结构保证了其有效性。\n 二、二叉查找树  二叉查找树是指一棵空树或者具有下列性质的二叉树：\n 若任意节点的左子树不空，则左子树上所有节点的值均小于它的根节点的值； 若任意节点的右子树不空，则右子树上所有节点的值均大于它的根节点的值； 任意节点的左、右子树也分别为二叉查找树；   上面是二叉查找树的正式的定义，其实一般情况下，只需要记住二叉查找树的左子树的值都小于根，右子树的值都大于根，就已足够。\n二叉查找树的构建是通过一个值一个值插入来构建的，哪怕有一组用来构建二叉查找树的值，二叉查找树也只能通过逐个插入来构建。\n举例：1、4、3、5、6、2、7 这个序列： 但同样的7个数字，如果不是按照上述插入方式插入的话，得到的二叉查找树的结构就会大相径庭。比如一个很容易发现的规律是：序列中第一个插入的元素一定会成为朴素二叉查找树的根节点。\n三、AVL树 由于朴素二叉查找树在极端情况下（即插入序列为有序序列）构建的查找树退化成一个单链表，使得在二叉查找树上进行查询的时间复杂度退化成O(n)。因此，为了保证查询高效，我们必须在插入元素后，对树的结构进行调整，使树尽量「宽」，而非尽量「深」，使得树能够保证平均查询复杂度始终保持在O(logN)数量级。\n为了衡量一棵树是否需要调整，我们需要有一个方式对树的状态进行度量。在AVL树中，我们选择的度量方式是比较子树的高度。\n  路径长度：从根节点到叶子节点经过的节点数量（包含根节点和叶子结点） 树的高度：一棵树的所有路径里最长路径的长度   在AVL树结构中，当一棵树的左子树与右子树的高度差的绝对值超过2时，就需要对树的结构进行调整了，这种调整在一般的文章讨论中成为「旋转」，其实本质就是对树中一些指针的指向进行调整的过程，它和链表插入也没什么本质的区别，都是指针调整而已。\n那么 AVL 树是怎么做的呢？\n首先 AVL 树将需要调整的情况分成了四类：\n 在左子树的左子树上做插入 在左子树的右子树上做插入 在右子树的左子树上做插入 在右子树的右子树上做插入  其中类型 1、4 镜像对称，类型 2、3 镜像对称。因此我们只需要研究类型 1 和类型 2 即可。\n 这里额外插一句，从上文对情况分类讨论时的用词「左子树的左子树」「右子树的左子树」等，我们可以很清晰地发现关于 AVL 结构调整的操作是在两层（即子树，以及子树的子树）上去操作的，这一定程度上有别于一些简单的递归操作时仅仅只在一层上去操作，此处需要格外注意去理解。\n  另外，关于如何找到要调整的根节点，这块看看具体的代码实现就清晰了，文字描述反而容易增加理解难度，因此此处不用文字赘述。\n 1、4两种情况的处理 关于这种调整是如何进行的，也话不多说，看图即可。\n上图描述了如何处理 在左子树的左子树上做插入， 即第一类情况需要做出的调整。 用文字描述的话就是：让根节点成为其左子树的右子树，然后让左子树原来的右子树成为根节点新的左子树。经过调整后，原左子树变成了根节点。",
  "keywords": [
    
  ],
  "articleBody": "题记：AVL树是笔者在上学时就一直没弄懂的数据结构，时隔多年重学数据结构，终于跨越了新手误区，成功理解了它的旋转，特作此文以记录一下。\n 注：本文默认读者已对二叉查找树、AVL树的基本功能有了一个感性认识，因此不赘述其查询过程，也不分析其查询复杂度，仅就其理解上的难点给出说明。\n 一、正确理解递归 树是一个典型的递归定义的数据结构，在树上执行的操作很多都是递归进行的，因此要理解树上的操作，我们首先需要正确理解递归。\n笔者在第一次学习递归时，一度试图跟着递归调用一直走到递归终止，然后跟着递归弹栈，以理解全过程。这种策略在理解迭代型程序是可行的，但是理解递归程序切不可这么做。试图跟着递归程序理解其递归全过程，是新手学习递归过程中最容易进入的误区。\n那么应该如何正确理解递归呢？我们可以考虑高中数学里一个常见的递归（递推）结构：数列。当我们描述一个数列时，有时我们可以给定一个数列的通项公式，但更多时候，通项公式并没有数列的递推公式容易得到。所以，也时常有数列是以递推公式+首项的方式进行描述的，这其实就是理解递归的正确方式。\n 在理解递归时，只需要考虑相邻结构，以及递归终止条件（即相当于数列首项）即可，数学结构保证了其有效性。\n 二、二叉查找树  二叉查找树是指一棵空树或者具有下列性质的二叉树：\n 若任意节点的左子树不空，则左子树上所有节点的值均小于它的根节点的值； 若任意节点的右子树不空，则右子树上所有节点的值均大于它的根节点的值； 任意节点的左、右子树也分别为二叉查找树；   上面是二叉查找树的正式的定义，其实一般情况下，只需要记住二叉查找树的左子树的值都小于根，右子树的值都大于根，就已足够。\n二叉查找树的构建是通过一个值一个值插入来构建的，哪怕有一组用来构建二叉查找树的值，二叉查找树也只能通过逐个插入来构建。\n举例：1、4、3、5、6、2、7 这个序列： 但同样的7个数字，如果不是按照上述插入方式插入的话，得到的二叉查找树的结构就会大相径庭。比如一个很容易发现的规律是：序列中第一个插入的元素一定会成为朴素二叉查找树的根节点。\n三、AVL树 由于朴素二叉查找树在极端情况下（即插入序列为有序序列）构建的查找树退化成一个单链表，使得在二叉查找树上进行查询的时间复杂度退化成O(n)。因此，为了保证查询高效，我们必须在插入元素后，对树的结构进行调整，使树尽量「宽」，而非尽量「深」，使得树能够保证平均查询复杂度始终保持在O(logN)数量级。\n为了衡量一棵树是否需要调整，我们需要有一个方式对树的状态进行度量。在AVL树中，我们选择的度量方式是比较子树的高度。\n  路径长度：从根节点到叶子节点经过的节点数量（包含根节点和叶子结点） 树的高度：一棵树的所有路径里最长路径的长度   在AVL树结构中，当一棵树的左子树与右子树的高度差的绝对值超过2时，就需要对树的结构进行调整了，这种调整在一般的文章讨论中成为「旋转」，其实本质就是对树中一些指针的指向进行调整的过程，它和链表插入也没什么本质的区别，都是指针调整而已。\n那么 AVL 树是怎么做的呢？\n首先 AVL 树将需要调整的情况分成了四类：\n 在左子树的左子树上做插入 在左子树的右子树上做插入 在右子树的左子树上做插入 在右子树的右子树上做插入  其中类型 1、4 镜像对称，类型 2、3 镜像对称。因此我们只需要研究类型 1 和类型 2 即可。\n 这里额外插一句，从上文对情况分类讨论时的用词「左子树的左子树」「右子树的左子树」等，我们可以很清晰地发现关于 AVL 结构调整的操作是在两层（即子树，以及子树的子树）上去操作的，这一定程度上有别于一些简单的递归操作时仅仅只在一层上去操作，此处需要格外注意去理解。\n  另外，关于如何找到要调整的根节点，这块看看具体的代码实现就清晰了，文字描述反而容易增加理解难度，因此此处不用文字赘述。\n 1、4两种情况的处理 关于这种调整是如何进行的，也话不多说，看图即可。\n上图描述了如何处理 在左子树的左子树上做插入， 即第一类情况需要做出的调整。 用文字描述的话就是：让根节点成为其左子树的右子树，然后让左子树原来的右子树成为根节点新的左子树。经过调整后，原左子树变成了根节点。\n相信上面这段描述结合图示应该足够清晰。\n将上面的这个调整过程写成代码的话：\nvoid rotateWithLeftChild (AVLNode** node) {  // 先标记一下左子树为t  auto t = (*node)-left;  // 让左子树的右子树成为根节点的左子树  (*node)-left = t-right;  // 让根节点成为左子树的右子树  t-right = *node;   // 在调整完后，重新计算一下各节点的高度  (*node)-height = std::max(height((*node)-left), height((*node)-right)) + 1;  t-height = std::max(height(t-left), (*node)-height) + 1;   // 重新标记一下根节点  *node = t; } 第四种情况的处理完全是镜面对称的：\nvoid rotateWithRightChild (AVLNode** node) {  // 先标记一下右子树为t  auto t = (*node)-right;  // 让右子树的左子树成为根节点的右子树  (*node)-right = t-left;  // 让根节点成为右子树的左子树  t-left = *node;   // 在调整完后，重新计算一下各节点的高度  (*node)-height = std::max(height((*node)-left), height((*node)-right)) + 1;  t-height = std::max(height(t-right), (*node)-height) + 1;   // 重新标记一下根节点  *node = t; } 至此，我们就有了处理2、3两种情况的武器\n2、3两种情况的处理 话不多说，还是先看图吧，我们依旧以在左子树的右子树插入为例来看\n从图上我们可以发现，情况2其实可以分解成两步：\n 处理在左子树上的情况4 处理在根节点上的情况1  由此，代码也可以这么写了\nvoid doubleRotateWithLeftChild (AVLNode** node) {  // 处理左子树上的情况4  rotateWithRightChild(\u0026((*node)-left));  // 处理根节点上的情况1  rotateWithLeftChild(node); } 同理，情况3也是情况2的镜像对称：\nvoid doubleRotateWithRightChild (AVLNode** node) {  // 处理右子树上的情况1  rotateWithLeftChild(\u0026((*node)-right));  // 处理根节点上的情况4  rotateWithRightChild(node); } 由此我们便搞定了AVL树中最艰难的树高再平衡过程，或者叫做「旋转」过程。\n四、完整代码 struct AVLNode {  int data;  int height;  AVLNode* left;  AVLNode* right; };  class AVLTree { public:  AVLTree()  : m_pRoot(nullptr)  {   }   ~AVLTree()  {  dispose(m_pRoot);  }   bool contains(int value)  {  return contains(value, m_pRoot);  }   void insert(int value)  {  insert(value, \u0026m_pRoot);  }   int height(AVLNode* t) const  {  return t == nullptr ? -1 : t-height;  }   void print()  {  print(m_pRoot);  }   private:   void dispose(AVLNode* node)  {   if (node-left != nullptr)  {  dispose(node-left);  }  if (node-right != nullptr)  {  dispose(node-right);  }  delete node;  }   bool contains(int value, AVLNode* node)  {  if (node == nullptr)  {  return false;  }   if (value == node-data)  {  return true;  }  else if (value  node-data)  {  return contains(value, node-left);  }  else  {  return contains(value, node-right);  }  }   void insert(int value, AVLNode** node) {  if (*node == nullptr) {  *node = new AVLNode{ value, 0, nullptr, nullptr };  }  else if (value  (*node)-data) {  insert(value, \u0026((*node)-left));  if (height((*node)-left) - height((*node)-right) == 2) {  if (value  (*node)-left-data) {  rotateWithLeftChild(node);  }  else {  doubleRotateWithLeftChild(node);  }  }  }  else if ((*node)-data  value) {  insert(value, \u0026((*node)-right));  if (height((*node)-right) - height((*node)-left) == 2) {  if (value  (*node)-right-data) {  rotateWithRightChild(node);  }  else {  doubleRotateWithRightChild(node);  }  }  }   (*node)-height = std::max(height((*node)-left), height((*node)-right)) + 1;  }   void rotateWithLeftChild (AVLNode** node)  {  auto t = (*node)-left;  (*node)-left = t-right;  t-right = *node;   (*node)-height = std::max(height((*node)-left), height((*node)-right)) + 1;  t-height = std::max(height(t-left), (*node)-height) + 1;   *node = t;  }   void doubleRotateWithLeftChild (AVLNode** node)  {  rotateWithRightChild(\u0026((*node)-left));  rotateWithLeftChild(node);  }   void rotateWithRightChild (AVLNode** node)  {  auto t = (*node)-right;  (*node)-right = t-left;  t-left = *node;   (*node)-height = std::max(height((*node)-left), height((*node)-right)) + 1;  t-height = std::max(height(t-right), (*node)-height) + 1;  *node = t;  }   void doubleRotateWithRightChild (AVLNode** node)  {  rotateWithLeftChild(\u0026((*node)-right));  rotateWithRightChild(node);  }     void print(AVLNode* node)  {  if (node-left != nullptr)  {  print(node-left);  }   std::cout  node-data  \" \";   if (node-right != nullptr)  {  print(node-right);  }  }     AVLNode* m_pRoot; }; ",
  "wordCount" : "481",
  "inLanguage": "en",
  "datePublished": "2022-02-20T21:01:08+08:00",
  "dateModified": "2022-02-20T21:01:08+08:00",
  "mainEntityOfPage": {
    "@type": "WebPage",
    "@id": "/posts/avl-tree/"
  },
  "publisher": {
    "@type": "Organization",
    "name": "回忆补时",
    "logo": {
      "@type": "ImageObject",
      "url": "/favicon.ico"
    }
  }
}
</script>
</head>

<body class="" id="top">
<script>
    if (localStorage.getItem("pref-theme") === "dark") {
        document.body.classList.add('dark');
    } else if (localStorage.getItem("pref-theme") === "light") {
        document.body.classList.remove('dark')
    } else if (window.matchMedia('(prefers-color-scheme: dark)').matches) {
        document.body.classList.add('dark');
    }

</script>

<header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="/" accesskey="h" title="回忆补时 (Alt + H)">回忆补时</a>
            <span class="logo-switches">
                <button id="theme-toggle" accesskey="t" title="(Alt + T)">
                    <svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                    </svg>
                    <svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <circle cx="12" cy="12" r="5"></circle>
                        <line x1="12" y1="1" x2="12" y2="3"></line>
                        <line x1="12" y1="21" x2="12" y2="23"></line>
                        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                        <line x1="1" y1="12" x2="3" y2="12"></line>
                        <line x1="21" y1="12" x2="23" y2="12"></line>
                        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                    </svg>
                </button>
            </span>
        </div>
        <ul id="menu">
            <li>
                <a href="/archives" title="Archive">
                    <span>Archive</span>
                </a>
            </li>
        </ul>
    </nav>
</header>
<main class="main">

<article class="post-single">
  <header class="post-header">
    <div class="breadcrumbs"><a href="/">Home</a>&nbsp;»&nbsp;<a href="/posts/">Posts</a></div>
    <h1 class="post-title">
      AVL树
    </h1>
    <div class="post-meta"><span title='2022-02-20 21:01:08 +0800 +0800'>February 20, 2022</span>&nbsp;·&nbsp;3 min

</div>
  </header> <div class="toc">
    <details >
        <summary accesskey="c" title="(Alt + C)">
            <span class="details">Table of Contents</span>
        </summary>

        <div class="inner"><ul>
                <li>
                    <a href="#%e4%b8%80%e6%ad%a3%e7%a1%ae%e7%90%86%e8%a7%a3%e9%80%92%e5%bd%92" aria-label="一、正确理解递归">一、正确理解递归</a></li>
                <li>
                    <a href="#%e4%ba%8c%e4%ba%8c%e5%8f%89%e6%9f%a5%e6%89%be%e6%a0%91" aria-label="二、二叉查找树">二、二叉查找树</a></li>
                <li>
                    <a href="#%e4%b8%89avl%e6%a0%91" aria-label="三、AVL树">三、AVL树</a><ul>
                        
                <li>
                    <a href="#14%e4%b8%a4%e7%a7%8d%e6%83%85%e5%86%b5%e7%9a%84%e5%a4%84%e7%90%86" aria-label="1、4两种情况的处理">1、4两种情况的处理</a></li>
                <li>
                    <a href="#23%e4%b8%a4%e7%a7%8d%e6%83%85%e5%86%b5%e7%9a%84%e5%a4%84%e7%90%86" aria-label="2、3两种情况的处理">2、3两种情况的处理</a></li></ul>
                </li>
                <li>
                    <a href="#%e5%9b%9b%e5%ae%8c%e6%95%b4%e4%bb%a3%e7%a0%81" aria-label="四、完整代码">四、完整代码</a>
                </li>
            </ul>
        </div>
    </details>
</div>

  <div class="post-content"><p>题记：AVL树是笔者在上学时就一直没弄懂的数据结构，时隔多年重学数据结构，终于跨越了新手误区，成功理解了它的旋转，特作此文以记录一下。</p>
<blockquote>
<p>注：本文默认读者已对二叉查找树、AVL树的基本功能有了一个感性认识，因此不赘述其查询过程，也不分析其查询复杂度，仅就其理解上的难点给出说明。</p>
</blockquote>
<h2 id="一正确理解递归">一、正确理解递归<a hidden class="anchor" aria-hidden="true" href="#一正确理解递归">#</a></h2>
<p>树是一个典型的递归定义的数据结构，在树上执行的操作很多都是递归进行的，因此要理解树上的操作，我们首先需要正确理解递归。</p>
<p>笔者在第一次学习递归时，一度试图跟着递归调用一直走到递归终止，然后跟着递归弹栈，以理解全过程。这种策略在理解迭代型程序是可行的，但是理解递归程序切不可这么做。试图跟着递归程序理解其递归全过程，是新手学习递归过程中最容易进入的误区。</p>
<p>那么应该如何正确理解递归呢？我们可以考虑高中数学里一个常见的递归（递推）结构：数列。当我们描述一个数列时，有时我们可以给定一个数列的通项公式，但更多时候，通项公式并没有数列的递推公式容易得到。所以，也时常有数列是以<code>递推公式+首项</code>的方式进行描述的，这其实就是理解递归的正确方式。</p>
<blockquote>
<p>在理解递归时，只需要考虑相邻结构，以及递归终止条件（即相当于数列首项）即可，数学结构保证了其有效性。</p>
</blockquote>
<h2 id="二二叉查找树">二、二叉查找树<a hidden class="anchor" aria-hidden="true" href="#二二叉查找树">#</a></h2>
<blockquote>
<p>二叉查找树是指一棵空树或者具有下列性质的二叉树：</p>
<ol>
<li>若任意节点的左子树不空，则左子树上所有节点的值均小于它的根节点的值；</li>
<li>若任意节点的右子树不空，则右子树上所有节点的值均大于它的根节点的值；</li>
<li>任意节点的左、右子树也分别为二叉查找树；</li>
</ol>
</blockquote>
<p>上面是二叉查找树的正式的定义，其实一般情况下，只需要记住二叉查找树的左子树的值都小于根，右子树的值都大于根，就已足够。</p>
<p>二叉查找树的构建是通过一个值一个值插入来构建的，哪怕有一组用来构建二叉查找树的值，二叉查找树也只能通过逐个插入来构建。</p>
<p>举例：1、4、3、5、6、2、7 这个序列：
<img loading="lazy" src="/avl-tree-image/1.jpg" alt="二叉查找树插入示例"  />
</p>
<p>但同样的7个数字，如果不是按照上述插入方式插入的话，得到的二叉查找树的结构就会大相径庭。比如一个很容易发现的规律是：序列中第一个插入的元素一定会成为朴素二叉查找树的根节点。</p>
<h2 id="三avl树">三、AVL树<a hidden class="anchor" aria-hidden="true" href="#三avl树">#</a></h2>
<p>由于朴素二叉查找树在极端情况下（即插入序列为有序序列）构建的查找树退化成一个单链表，使得在二叉查找树上进行查询的时间复杂度退化成O(n)。因此，为了保证查询高效，我们必须在插入元素后，对树的结构进行调整，使树尽量「宽」，而非尽量「深」，使得树能够保证平均查询复杂度始终保持在O(logN)数量级。</p>
<p>为了衡量一棵树是否需要调整，我们需要有一个方式对树的状态进行度量。在AVL树中，我们选择的度量方式是比较子树的高度。</p>
<blockquote>
<ul>
<li>路径长度：从根节点到叶子节点经过的节点数量（包含根节点和叶子结点）</li>
<li>树的高度：一棵树的所有路径里最长路径的长度</li>
</ul>
</blockquote>
<p>在AVL树结构中，当一棵树的左子树与右子树的高度差的绝对值超过2时，就需要对树的结构进行调整了，这种调整在一般的文章讨论中成为「旋转」，其实本质就是对树中一些指针的指向进行调整的过程，它和链表插入也没什么本质的区别，都是指针调整而已。</p>
<p>那么 AVL 树是怎么做的呢？</p>
<p>首先 AVL 树将需要调整的情况分成了四类：</p>
<ol>
<li>在左子树的左子树上做插入</li>
<li>在左子树的右子树上做插入</li>
<li>在右子树的左子树上做插入</li>
<li>在右子树的右子树上做插入</li>
</ol>
<p>其中类型 1、4 镜像对称，类型 2、3 镜像对称。因此我们只需要研究类型 1 和类型 2 即可。</p>
<blockquote>
<p>这里额外插一句，从上文对情况分类讨论时的用词「左子树的左子树」「右子树的左子树」等，我们可以很清晰地发现关于 AVL 结构调整的操作是在两层（即子树，以及子树的子树）上去操作的，这一定程度上有别于一些简单的递归操作时仅仅只在一层上去操作，此处需要格外注意去理解。</p>
</blockquote>
<blockquote>
<p>另外，关于如何找到要调整的根节点，这块看看具体的代码实现就清晰了，文字描述反而容易增加理解难度，因此此处不用文字赘述。</p>
</blockquote>
<h3 id="14两种情况的处理">1、4两种情况的处理<a hidden class="anchor" aria-hidden="true" href="#14两种情况的处理">#</a></h3>
<p>关于这种调整是如何进行的，也话不多说，看图即可。</p>
<p><img loading="lazy" src="/avl-tree-image/2.jpg" alt="左旋转"  />
</p>
<p>上图描述了如何处理 <code>在左子树的左子树上做插入</code>， 即第一类情况需要做出的调整。
用文字描述的话就是：让根节点成为其左子树的右子树，然后让左子树原来的右子树成为根节点新的左子树。经过调整后，原左子树变成了根节点。</p>
<p>相信上面这段描述结合图示应该足够清晰。</p>
<p>将上面的这个调整过程写成代码的话：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c++" data-lang="c++"><span style="display:flex;"><span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">rotateWithLeftChild</span> (AVLNode<span style="color:#f92672">**</span> node)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 先标记一下左子树为t
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">auto</span> t <span style="color:#f92672">=</span> (<span style="color:#f92672">*</span>node)<span style="color:#f92672">-&gt;</span>left;
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 让左子树的右子树成为根节点的左子树
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    (<span style="color:#f92672">*</span>node)<span style="color:#f92672">-&gt;</span>left <span style="color:#f92672">=</span> t<span style="color:#f92672">-&gt;</span>right;
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 让根节点成为左子树的右子树
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    t<span style="color:#f92672">-&gt;</span>right <span style="color:#f92672">=</span> <span style="color:#f92672">*</span>node;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 在调整完后，重新计算一下各节点的高度
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    (<span style="color:#f92672">*</span>node)<span style="color:#f92672">-&gt;</span>height <span style="color:#f92672">=</span> std<span style="color:#f92672">::</span>max(height((<span style="color:#f92672">*</span>node)<span style="color:#f92672">-&gt;</span>left), height((<span style="color:#f92672">*</span>node)<span style="color:#f92672">-&gt;</span>right)) <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>    t<span style="color:#f92672">-&gt;</span>height <span style="color:#f92672">=</span> std<span style="color:#f92672">::</span>max(height(t<span style="color:#f92672">-&gt;</span>left), (<span style="color:#f92672">*</span>node)<span style="color:#f92672">-&gt;</span>height) <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 重新标记一下根节点
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#f92672">*</span>node <span style="color:#f92672">=</span> t;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>第四种情况的处理完全是镜面对称的：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c++" data-lang="c++"><span style="display:flex;"><span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">rotateWithRightChild</span> (AVLNode<span style="color:#f92672">**</span> node)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 先标记一下右子树为t
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">auto</span> t <span style="color:#f92672">=</span> (<span style="color:#f92672">*</span>node)<span style="color:#f92672">-&gt;</span>right;
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 让右子树的左子树成为根节点的右子树
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    (<span style="color:#f92672">*</span>node)<span style="color:#f92672">-&gt;</span>right <span style="color:#f92672">=</span> t<span style="color:#f92672">-&gt;</span>left;
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 让根节点成为右子树的左子树
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    t<span style="color:#f92672">-&gt;</span>left <span style="color:#f92672">=</span> <span style="color:#f92672">*</span>node;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 在调整完后，重新计算一下各节点的高度
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    (<span style="color:#f92672">*</span>node)<span style="color:#f92672">-&gt;</span>height <span style="color:#f92672">=</span> std<span style="color:#f92672">::</span>max(height((<span style="color:#f92672">*</span>node)<span style="color:#f92672">-&gt;</span>left), height((<span style="color:#f92672">*</span>node)<span style="color:#f92672">-&gt;</span>right)) <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>    t<span style="color:#f92672">-&gt;</span>height <span style="color:#f92672">=</span> std<span style="color:#f92672">::</span>max(height(t<span style="color:#f92672">-&gt;</span>right), (<span style="color:#f92672">*</span>node)<span style="color:#f92672">-&gt;</span>height) <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 重新标记一下根节点
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#f92672">*</span>node <span style="color:#f92672">=</span> t;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>至此，我们就有了处理2、3两种情况的武器</p>
<h3 id="23两种情况的处理">2、3两种情况的处理<a hidden class="anchor" aria-hidden="true" href="#23两种情况的处理">#</a></h3>
<p>话不多说，还是先看图吧，我们依旧以在<code>左子树的右子树插入</code>为例来看</p>
<p><img loading="lazy" src="/avl-tree-image/3.jpg" alt="先右后左旋转"  />
</p>
<p>从图上我们可以发现，情况2其实可以分解成两步：</p>
<ol>
<li>处理在左子树上的情况4</li>
<li>处理在根节点上的情况1</li>
</ol>
<p>由此，代码也可以这么写了</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c++" data-lang="c++"><span style="display:flex;"><span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">doubleRotateWithLeftChild</span> (AVLNode<span style="color:#f92672">**</span> node)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 处理左子树上的情况4
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    rotateWithRightChild(<span style="color:#f92672">&amp;</span>((<span style="color:#f92672">*</span>node)<span style="color:#f92672">-&gt;</span>left));
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 处理根节点上的情况1
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    rotateWithLeftChild(node);
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>同理，情况3也是情况2的镜像对称：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c++" data-lang="c++"><span style="display:flex;"><span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">doubleRotateWithRightChild</span> (AVLNode<span style="color:#f92672">**</span> node)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 处理右子树上的情况1
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    rotateWithLeftChild(<span style="color:#f92672">&amp;</span>((<span style="color:#f92672">*</span>node)<span style="color:#f92672">-&gt;</span>right));
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 处理根节点上的情况4
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    rotateWithRightChild(node);
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>由此我们便搞定了AVL树中最艰难的树高再平衡过程，或者叫做「旋转」过程。</p>
<h2 id="四完整代码">四、完整代码<a hidden class="anchor" aria-hidden="true" href="#四完整代码">#</a></h2>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c++" data-lang="c++"><span style="display:flex;"><span><span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">AVLNode</span>
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">int</span> data;
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">int</span> height;
</span></span><span style="display:flex;"><span>  AVLNode<span style="color:#f92672">*</span> left;
</span></span><span style="display:flex;"><span>  AVLNode<span style="color:#f92672">*</span> right;
</span></span><span style="display:flex;"><span>};
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">AVLTree</span>
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>
</span></span><span style="display:flex;"><span>  AVLTree()
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">:</span> m_pRoot(<span style="color:#66d9ef">nullptr</span>)
</span></span><span style="display:flex;"><span>  {
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>  
</span></span><span style="display:flex;"><span>  <span style="color:#f92672">~</span>AVLTree()
</span></span><span style="display:flex;"><span>  {
</span></span><span style="display:flex;"><span>    dispose(m_pRoot);
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>  
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">bool</span> <span style="color:#a6e22e">contains</span>(<span style="color:#66d9ef">int</span> value)
</span></span><span style="display:flex;"><span>  {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> contains(value, m_pRoot);
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>  
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">insert</span>(<span style="color:#66d9ef">int</span> value)
</span></span><span style="display:flex;"><span>  {
</span></span><span style="display:flex;"><span>    insert(value, <span style="color:#f92672">&amp;</span>m_pRoot);
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>  
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">int</span> <span style="color:#a6e22e">height</span>(AVLNode<span style="color:#f92672">*</span> t) <span style="color:#66d9ef">const</span>
</span></span><span style="display:flex;"><span>  {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> t <span style="color:#f92672">==</span> <span style="color:#66d9ef">nullptr</span> <span style="color:#f92672">?</span> <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span> <span style="color:#f92672">:</span> t<span style="color:#f92672">-&gt;</span>height;
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>  
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">print</span>()
</span></span><span style="display:flex;"><span>  {
</span></span><span style="display:flex;"><span>    print(m_pRoot);
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>  
</span></span><span style="display:flex;"><span>  
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">private</span><span style="color:#f92672">:</span>
</span></span><span style="display:flex;"><span>  
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">void</span> dispose(AVLNode<span style="color:#f92672">*</span> node)
</span></span><span style="display:flex;"><span>  {
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> (node<span style="color:#f92672">-&gt;</span>left <span style="color:#f92672">!=</span> <span style="color:#66d9ef">nullptr</span>)
</span></span><span style="display:flex;"><span>    {
</span></span><span style="display:flex;"><span>      dispose(node<span style="color:#f92672">-&gt;</span>left);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> (node<span style="color:#f92672">-&gt;</span>right <span style="color:#f92672">!=</span> <span style="color:#66d9ef">nullptr</span>)
</span></span><span style="display:flex;"><span>    {
</span></span><span style="display:flex;"><span>      dispose(node<span style="color:#f92672">-&gt;</span>right);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">delete</span> node;
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>  
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">bool</span> <span style="color:#a6e22e">contains</span>(<span style="color:#66d9ef">int</span> value, AVLNode<span style="color:#f92672">*</span> node)
</span></span><span style="display:flex;"><span>  {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> (node <span style="color:#f92672">==</span> <span style="color:#66d9ef">nullptr</span>)
</span></span><span style="display:flex;"><span>    {
</span></span><span style="display:flex;"><span>      <span style="color:#66d9ef">return</span> false;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> (value <span style="color:#f92672">==</span> node<span style="color:#f92672">-&gt;</span>data)
</span></span><span style="display:flex;"><span>    {
</span></span><span style="display:flex;"><span>      <span style="color:#66d9ef">return</span> true;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">else</span> <span style="color:#66d9ef">if</span> (value <span style="color:#f92672">&lt;</span> node<span style="color:#f92672">-&gt;</span>data)
</span></span><span style="display:flex;"><span>    {
</span></span><span style="display:flex;"><span>      <span style="color:#66d9ef">return</span> contains(value, node<span style="color:#f92672">-&gt;</span>left);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">else</span>
</span></span><span style="display:flex;"><span>    {
</span></span><span style="display:flex;"><span>      <span style="color:#66d9ef">return</span> contains(value, node<span style="color:#f92672">-&gt;</span>right);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>  
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">insert</span>(<span style="color:#66d9ef">int</span> value, AVLNode<span style="color:#f92672">**</span> node) {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> (<span style="color:#f92672">*</span>node <span style="color:#f92672">==</span> <span style="color:#66d9ef">nullptr</span>) {
</span></span><span style="display:flex;"><span>      <span style="color:#f92672">*</span>node <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> AVLNode{ value, <span style="color:#ae81ff">0</span>, <span style="color:#66d9ef">nullptr</span>, <span style="color:#66d9ef">nullptr</span> };
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">else</span> <span style="color:#66d9ef">if</span> (value <span style="color:#f92672">&lt;</span> (<span style="color:#f92672">*</span>node)<span style="color:#f92672">-&gt;</span>data) {
</span></span><span style="display:flex;"><span>      insert(value, <span style="color:#f92672">&amp;</span>((<span style="color:#f92672">*</span>node)<span style="color:#f92672">-&gt;</span>left));
</span></span><span style="display:flex;"><span>      <span style="color:#66d9ef">if</span> (height((<span style="color:#f92672">*</span>node)<span style="color:#f92672">-&gt;</span>left) <span style="color:#f92672">-</span> height((<span style="color:#f92672">*</span>node)<span style="color:#f92672">-&gt;</span>right) <span style="color:#f92672">==</span> <span style="color:#ae81ff">2</span>) {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> (value <span style="color:#f92672">&lt;</span> (<span style="color:#f92672">*</span>node)<span style="color:#f92672">-&gt;</span>left<span style="color:#f92672">-&gt;</span>data) {
</span></span><span style="display:flex;"><span>          rotateWithLeftChild(node);
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">else</span> {
</span></span><span style="display:flex;"><span>          doubleRotateWithLeftChild(node);
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>      }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">else</span> <span style="color:#66d9ef">if</span> ((<span style="color:#f92672">*</span>node)<span style="color:#f92672">-&gt;</span>data <span style="color:#f92672">&lt;</span> value) {
</span></span><span style="display:flex;"><span>      insert(value, <span style="color:#f92672">&amp;</span>((<span style="color:#f92672">*</span>node)<span style="color:#f92672">-&gt;</span>right));
</span></span><span style="display:flex;"><span>      <span style="color:#66d9ef">if</span> (height((<span style="color:#f92672">*</span>node)<span style="color:#f92672">-&gt;</span>right) <span style="color:#f92672">-</span> height((<span style="color:#f92672">*</span>node)<span style="color:#f92672">-&gt;</span>left) <span style="color:#f92672">==</span> <span style="color:#ae81ff">2</span>) {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> (value <span style="color:#f92672">&gt;</span> (<span style="color:#f92672">*</span>node)<span style="color:#f92672">-&gt;</span>right<span style="color:#f92672">-&gt;</span>data) {
</span></span><span style="display:flex;"><span>          rotateWithRightChild(node);
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">else</span> {
</span></span><span style="display:flex;"><span>          doubleRotateWithRightChild(node);
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>      }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    (<span style="color:#f92672">*</span>node)<span style="color:#f92672">-&gt;</span>height <span style="color:#f92672">=</span> std<span style="color:#f92672">::</span>max(height((<span style="color:#f92672">*</span>node)<span style="color:#f92672">-&gt;</span>left), height((<span style="color:#f92672">*</span>node)<span style="color:#f92672">-&gt;</span>right)) <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>  
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">rotateWithLeftChild</span> (AVLNode<span style="color:#f92672">**</span> node)
</span></span><span style="display:flex;"><span>  {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">auto</span> t <span style="color:#f92672">=</span> (<span style="color:#f92672">*</span>node)<span style="color:#f92672">-&gt;</span>left;
</span></span><span style="display:flex;"><span>    (<span style="color:#f92672">*</span>node)<span style="color:#f92672">-&gt;</span>left <span style="color:#f92672">=</span> t<span style="color:#f92672">-&gt;</span>right;
</span></span><span style="display:flex;"><span>    t<span style="color:#f92672">-&gt;</span>right <span style="color:#f92672">=</span> <span style="color:#f92672">*</span>node;
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    (<span style="color:#f92672">*</span>node)<span style="color:#f92672">-&gt;</span>height <span style="color:#f92672">=</span> std<span style="color:#f92672">::</span>max(height((<span style="color:#f92672">*</span>node)<span style="color:#f92672">-&gt;</span>left), height((<span style="color:#f92672">*</span>node)<span style="color:#f92672">-&gt;</span>right)) <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>    t<span style="color:#f92672">-&gt;</span>height <span style="color:#f92672">=</span> std<span style="color:#f92672">::</span>max(height(t<span style="color:#f92672">-&gt;</span>left), (<span style="color:#f92672">*</span>node)<span style="color:#f92672">-&gt;</span>height) <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">*</span>node <span style="color:#f92672">=</span> t;
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>  
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">doubleRotateWithLeftChild</span> (AVLNode<span style="color:#f92672">**</span> node)
</span></span><span style="display:flex;"><span>  {
</span></span><span style="display:flex;"><span>    rotateWithRightChild(<span style="color:#f92672">&amp;</span>((<span style="color:#f92672">*</span>node)<span style="color:#f92672">-&gt;</span>left));
</span></span><span style="display:flex;"><span>    rotateWithLeftChild(node);
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>  
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">rotateWithRightChild</span> (AVLNode<span style="color:#f92672">**</span> node)
</span></span><span style="display:flex;"><span>  {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">auto</span> t <span style="color:#f92672">=</span> (<span style="color:#f92672">*</span>node)<span style="color:#f92672">-&gt;</span>right;
</span></span><span style="display:flex;"><span>    (<span style="color:#f92672">*</span>node)<span style="color:#f92672">-&gt;</span>right <span style="color:#f92672">=</span> t<span style="color:#f92672">-&gt;</span>left;
</span></span><span style="display:flex;"><span>    t<span style="color:#f92672">-&gt;</span>left <span style="color:#f92672">=</span> <span style="color:#f92672">*</span>node;
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    (<span style="color:#f92672">*</span>node)<span style="color:#f92672">-&gt;</span>height <span style="color:#f92672">=</span> std<span style="color:#f92672">::</span>max(height((<span style="color:#f92672">*</span>node)<span style="color:#f92672">-&gt;</span>left), height((<span style="color:#f92672">*</span>node)<span style="color:#f92672">-&gt;</span>right)) <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>    t<span style="color:#f92672">-&gt;</span>height <span style="color:#f92672">=</span> std<span style="color:#f92672">::</span>max(height(t<span style="color:#f92672">-&gt;</span>right), (<span style="color:#f92672">*</span>node)<span style="color:#f92672">-&gt;</span>height) <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">*</span>node <span style="color:#f92672">=</span> t;
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>  
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">doubleRotateWithRightChild</span> (AVLNode<span style="color:#f92672">**</span> node)
</span></span><span style="display:flex;"><span>  {
</span></span><span style="display:flex;"><span>    rotateWithLeftChild(<span style="color:#f92672">&amp;</span>((<span style="color:#f92672">*</span>node)<span style="color:#f92672">-&gt;</span>right));
</span></span><span style="display:flex;"><span>    rotateWithRightChild(node);
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>  
</span></span><span style="display:flex;"><span>  
</span></span><span style="display:flex;"><span>  
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">print</span>(AVLNode<span style="color:#f92672">*</span> node)
</span></span><span style="display:flex;"><span>  {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> (node<span style="color:#f92672">-&gt;</span>left <span style="color:#f92672">!=</span> <span style="color:#66d9ef">nullptr</span>)
</span></span><span style="display:flex;"><span>    {
</span></span><span style="display:flex;"><span>      print(node<span style="color:#f92672">-&gt;</span>left);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>  
</span></span><span style="display:flex;"><span>    std<span style="color:#f92672">::</span>cout <span style="color:#f92672">&lt;&lt;</span> node<span style="color:#f92672">-&gt;</span>data <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34; &#34;</span>;
</span></span><span style="display:flex;"><span>  
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> (node<span style="color:#f92672">-&gt;</span>right <span style="color:#f92672">!=</span> <span style="color:#66d9ef">nullptr</span>)
</span></span><span style="display:flex;"><span>    {
</span></span><span style="display:flex;"><span>      print(node<span style="color:#f92672">-&gt;</span>right);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>  
</span></span><span style="display:flex;"><span>  
</span></span><span style="display:flex;"><span>  
</span></span><span style="display:flex;"><span>  AVLNode<span style="color:#f92672">*</span> m_pRoot;
</span></span><span style="display:flex;"><span>};
</span></span></code></pre></div>

  </div>

  <footer class="post-footer">
  </footer>
</article>
    </main>
    
<footer class="footer">
    <span>&copy; 2022 <a href="/">回忆补时</a></span>
    <span>
        Powered by
        <a href="https://gohugo.io/" rel="noopener noreferrer" target="_blank">Hugo</a> &
        <a href="https://git.io/hugopapermod" rel="noopener" target="_blank">PaperMod</a>
    </span>
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)" class="top-link" id="top-link" accesskey="g">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
        <path d="M12 6H0l6-6z" />
    </svg>
</a>

<script>
    let menu = document.getElementById('menu')
    if (menu) {
        menu.scrollLeft = localStorage.getItem("menu-scroll-position");
        menu.onscroll = function () {
            localStorage.setItem("menu-scroll-position", menu.scrollLeft);
        }
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });

</script>
<script>
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

</script>
<script>
    document.getElementById("theme-toggle").addEventListener("click", () => {
        if (document.body.className.includes("dark")) {
            document.body.classList.remove('dark');
            localStorage.setItem("pref-theme", 'light');
        } else {
            document.body.classList.add('dark');
            localStorage.setItem("pref-theme", 'dark');
        }
    })

</script>
</body>

</html>
